generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  INVITED
}

enum AuditActorType {
  USER
  SYSTEM
}

enum ProjectStatus {
  PLANNING
  ACTIVE
  ON_HOLD
  CLOSED
  CANCELLED
}

enum ProjectMemberRole {
  PM
  LEAD
  CONTRIBUTOR
  REVIEWER
}

enum TaskStatus {
  DRAFT
  PLANNED
  IN_PROGRESS
  BLOCKED
  ON_HOLD
  COMPLETED
  CANCELLED
}

enum TaskPriority {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

enum TaskDependencyType {
  FS
  SF
  FF
  SS
}

enum DocumentType {
  CONTRACT
  REPORT
  PLAN
  REQUIREMENT
  RISK
  GENERIC
  CUSTOM
}

enum DocumentClassification {
  PUBLIC
  INTERNAL
  CONFIDENTIAL
  RESTRICTED
}

enum DocumentRetentionPolicy {
  DEFAULT
  LONG_TERM
  LEGAL_HOLD
}

enum DocumentVersionStatus {
  DRAFT
  IN_REVIEW
  APPROVED
  PUBLISHED
  ARCHIVED
}

enum VirusScanStatus {
  PENDING
  CLEAN
  INFECTED
  BYPASSED
}

enum DocumentApprovalDecision {
  APPROVED
  REJECTED
}

enum KPICategory {
  FINANCIAL
  SCHEDULE
  QUALITY
  RESOURCE
  COMPLIANCE
  CUSTOM
}

enum KPIStatus {
  PROPOSED
  UNDER_REVIEW
  ACTIVE
  MONITORING
  BREACHED
  RETIRED
}

enum KPIPrivacyLevel {
  PUBLIC
  INTERNAL
  RESTRICTED
}

enum KPIAggregationPeriod {
  WEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
}

enum KPIDataSourceType {
  MANUAL
  SYSTEM
  HYBRID
}

enum KPIValueSource {
  MANUAL_ENTRY
  API_INGEST
  FILE_UPLOAD
}

enum KPIVerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
}

enum WebhookChannel {
  GENERIC
  SLACK
  TEAMS
}

model User {
  id             String          @id @db.Uuid
  email          String          @unique
  fullName       String
  passwordHash   String
  passwordSetAt  DateTime?
  status         UserStatus      @default(ACTIVE)
  lastLoginAt    DateTime?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  roles          UserRole[]
  refreshTokens  RefreshToken[]
  auditLogs      AuditLog[]
  apiKeys        ApiKey[]       @relation("UserApiKeys")
  unsubscribeTokens UnsubscribeToken[] @relation("UserUnsubscribeTokens")
  emailLogs      EmailLog[]     @relation("UserEmailLogs")
  notifications  Notification[] @relation("UserNotifications")
  createdWebhooks WebhookSubscription[] @relation("WebhookCreator")
  updatedWebhooks WebhookSubscription[] @relation("WebhookUpdater")
  sponsoredProjects Project[]    @relation("ProjectSponsor")
  ownedProjects     Project[]    @relation("ProjectPMO")
  projectMemberships ProjectMember[]
  ownedTasks        Task[]       @relation("TaskOwner")
  reportedTasks     Task[]       @relation("TaskReporter")
  ownedDocuments    Document[]   @relation("DocumentOwner")
  taskComments      TaskComment[] @relation("TaskCommentAuthor")
  taskWatchers      TaskWatcher[] @relation("TaskWatcherUser")
  createdDocumentVersions DocumentVersion[] @relation("DocumentCreator")
  documentApprovals DocumentApproval[]
  stewardedKPIs     KPIDefinition[] @relation("KPISteward")
  approvedKPIs      KPIDefinition[] @relation("KPIApprover")
  collectedKPIData  KPISeries[]     @relation("KPIDataCollector")
  verifiedKPIData   KPISeries[]     @relation("KPIDataVerifier")
  linkedDocumentTasks DocumentTask[] @relation("DocumentTaskLinker")
  updatedSystemSettings SystemSetting[] @relation("SystemSettingUpdater")
  preferences       UserPreference[]
}

model Role {
  id             String            @id @db.Uuid
  code           String            @unique
  name           String
  description    String?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  users          UserRole[]
  permissions    RolePermission[]
}

model Permission {
  id             String            @id @db.Uuid
  code           String            @unique
  name           String
  description    String?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  roles          RolePermission[]
}

model RolePermission {
  roleId         String   @db.Uuid
  permissionId   String   @db.Uuid
  grantedAt      DateTime @default(now())

  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
}

model UserRole {
  userId     String   @db.Uuid
  roleId     String   @db.Uuid
  assignedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
}

model RefreshToken {
  id              String   @id @db.Uuid
  tokenHash       String   @unique
  userId          String   @db.Uuid
  issuedAt        DateTime @default(now())
  expiresAt       DateTime
  revokedAt       DateTime?
  revokedReason   String?
  replacedByToken String?
  ipAddress       String?
  userAgent       String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model AuditLog {
  id          String         @id @db.Uuid
  actorType   AuditActorType
  actorId     String?        @db.Uuid
  eventCode   String
  description String?
  ipAddress   String?
  userAgent   String?
  metadata    Json?
  createdAt   DateTime       @default(now())

  user User? @relation(fields: [actorId], references: [id])

  @@index([actorId])
  @@index([eventCode])
  @@index([createdAt])
}

model Project {
  id             String         @id @db.Uuid
  code           String         @unique
  name           String
  description    String?
  sponsorId      String         @db.Uuid
  sponsor        User           @relation("ProjectSponsor", fields: [sponsorId], references: [id])
  pmoOwnerId     String?        @db.Uuid
  pmoOwner       User?          @relation("ProjectPMO", fields: [pmoOwnerId], references: [id])
  status         ProjectStatus  @default(PLANNING)
  startDate      DateTime
  endDate        DateTime?
  actualStart    DateTime?
  actualEnd      DateTime?
  budgetPlanned  Decimal?       @db.Decimal(14, 2)
  metadata       Json?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  searchVector   Unsupported("tsvector")?

  tasks          Task[]
  documents      Document[]
  members        ProjectMember[]

  @@index([status])
  @@index([startDate])
  @@index([searchVector], map: "Project_search_vector_idx", type: Gin)
}

model ProjectMember {
  id             String             @id @db.Uuid
  projectId      String             @db.Uuid
  project        Project            @relation(fields: [projectId], references: [id], onDelete: Cascade)
  userId         String             @db.Uuid
  user           User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           ProjectMemberRole
  allocationPct  Int?               @default(0)
  joinedAt       DateTime           @default(now())
  leftAt         DateTime?
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  @@unique([projectId, userId, role])
  @@index([projectId])
  @@index([userId])
}

model Task {
  id                String        @id @db.Uuid
  code              String?       @unique @db.VarChar(50)
  projectId         String        @db.Uuid
  project           Project       @relation(fields: [projectId], references: [id], onDelete: Cascade)
  parentTaskId      String?       @db.Uuid
  parent            Task?         @relation("TaskHierarchy", fields: [parentTaskId], references: [id])
  children          Task[]        @relation("TaskHierarchy")
  title             String
  description       String?
  status            TaskStatus    @default(PLANNED)
  priority          TaskPriority  @default(NORMAL)
  ownerId           String        @db.Uuid
  owner             User          @relation("TaskOwner", fields: [ownerId], references: [id])
  reporterId        String?       @db.Uuid
  reporter          User?         @relation("TaskReporter", fields: [reporterId], references: [id])
  plannedStart      DateTime?
  plannedEnd        DateTime?
  actualStart       DateTime?
  actualEnd         DateTime?
  progressPct       Int           @default(0)
  effortPlannedHours Decimal?
  effortLoggedHours  Decimal?
  kanbanPosition    Int?
  linkedKpiIds      String[]      @default([])
  metadata          Json?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  lastReminderSentAt DateTime?
  searchVector      Unsupported("tsvector")?

  predecessorLinks TaskDependency[] @relation("TaskDependencySource")
  successorLinks   TaskDependency[] @relation("TaskDependencyTarget")
  comments         TaskComment[]
  watchers         TaskWatcher[]
  linkedDocuments  DocumentTask[]

  @@index([projectId])
  @@index([status])
  @@index([ownerId])
  @@index([projectId, status, kanbanPosition])
  @@index([status, kanbanPosition])
  @@index([searchVector], map: "Task_search_vector_idx", type: Gin)
}

model TaskDependency {
  id              String  @id @db.Uuid
  taskId          String  @db.Uuid
  dependsOnTaskId String  @db.Uuid
  type            TaskDependencyType @default(FS)
  lagMinutes      Int?

  task      Task @relation("TaskDependencySource", fields: [taskId], references: [id], onDelete: Cascade)
  dependsOn Task @relation("TaskDependencyTarget", fields: [dependsOnTaskId], references: [id], onDelete: Cascade)

  @@unique([taskId, dependsOnTaskId])
}

model TaskComment {
  id        String   @id @db.Uuid
  taskId    String   @db.Uuid
  authorId  String   @db.Uuid
  body      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  task   Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  author User @relation("TaskCommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
}

model TaskWatcher {
  id        String   @id @db.Uuid
  taskId    String   @db.Uuid
  userId    String   @db.Uuid
  createdAt DateTime @default(now())

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation("TaskWatcherUser", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([taskId, userId])
}

model Document {
  id               String                   @id @db.Uuid
  projectId        String                   @db.Uuid
  title            String
  docType          DocumentType
  classification   DocumentClassification
  ownerId          String                   @db.Uuid
  storageKey       String
  currentVersionId String?                  @db.Uuid @unique
  tags             String[]                 @default([])
  linkedTaskIds    String[]                 @default([])
  linkedKpiIds     String[]                 @default([])
  retentionPolicy  DocumentRetentionPolicy
  createdAt        DateTime                 @default(now())
  updatedAt        DateTime                 @updatedAt
  searchVector     Unsupported("tsvector")?

  project       Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  owner         User            @relation("DocumentOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  versions      DocumentVersion[]
  currentVersion DocumentVersion? @relation("DocumentCurrentVersion", fields: [currentVersionId], references: [id], onDelete: SetNull)
  linkedTasks   DocumentTask[]

  @@index([searchVector], map: "Document_search_vector_idx", type: Gin)
}

model DocumentVersion {
  id              String                 @id @db.Uuid
  documentId      String                 @db.Uuid
  versionNo       String
  status          DocumentVersionStatus  @default(IN_REVIEW)
  checksum        String
  sizeBytes       BigInt
  mimeType        String
  storageKey      String
  virusScanStatus VirusScanStatus        @default(PENDING)
  approvalChain   Json?
  createdBy       String                 @db.Uuid
  createdAt       DateTime               @default(now())

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  creator  User     @relation("DocumentCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  approvals DocumentApproval[]
  currentFor Document? @relation("DocumentCurrentVersion")
}

model DocumentApproval {
  id         String                    @id @db.Uuid
  versionId  String                    @db.Uuid
  approverId String                    @db.Uuid
  decision   DocumentApprovalDecision
  comment    String?
  decidedAt  DateTime                  @default(now())

  version  DocumentVersion @relation(fields: [versionId], references: [id], onDelete: Cascade)
  approver User            @relation(fields: [approverId], references: [id], onDelete: Cascade)

  @@unique([versionId, approverId])
}

model DocumentTask {
  id         String   @id @default(uuid()) @db.Uuid
  documentId String   @db.Uuid
  taskId     String   @db.Uuid
  linkedBy   String   @db.Uuid
  linkedAt   DateTime @default(now())
  createdAt  DateTime @default(now())

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  task     Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  linker   User     @relation("DocumentTaskLinker", fields: [linkedBy], references: [id])

  @@unique([documentId, taskId])
  @@index([documentId])
  @@index([taskId])
  @@index([linkedBy])
}

model KPIDefinition {
  id                     String                @id @db.Uuid
  code                   String                @unique @db.VarChar(20)
  name                   String                @db.VarChar(160)
  description            String?
  category               KPICategory
  calculationFormula     String
  targetValue            Decimal               @db.Decimal(20, 4)
  unit                   String                @db.VarChar(32)
  thresholdWarning       Decimal?              @db.Decimal(20, 4)
  thresholdCritical      Decimal?              @db.Decimal(20, 4)
  aggregationPeriod      KPIAggregationPeriod
  dataSourceType         KPIDataSourceType
  dataSourceReference    Json?
  stewardId              String                @db.Uuid
  approverId             String?               @db.Uuid
  status                 KPIStatus             @default(PROPOSED)
  privacyLevel           KPIPrivacyLevel       @default(INTERNAL)
  linkedProjectIds       String[]              @default([])
  linkedTaskIds          String[]              @default([])
  createdAt              DateTime              @default(now())
  updatedAt              DateTime              @updatedAt

  steward   User  @relation("KPISteward", fields: [stewardId], references: [id], onDelete: Cascade)
  approver  User? @relation("KPIApprover", fields: [approverId], references: [id], onDelete: SetNull)
  series    KPISeries[]

  @@index([category])
  @@index([status])
  @@index([stewardId])
}

model KPISeries {
  id                   String                  @id @db.Uuid
  kpiId                String                  @db.Uuid
  periodStart          DateTime                @db.Date
  periodEnd            DateTime                @db.Date
  actualValue          Decimal                 @db.Decimal(20, 4)
  valueSource          KPIValueSource
  collectedAt          DateTime                @default(now())
  collectedBy          String?                 @db.Uuid
  verificationStatus   KPIVerificationStatus   @default(PENDING)
  verificationNotes    String?
  verifiedBy           String?                 @db.Uuid
  verifiedAt           DateTime?

  kpi        KPIDefinition @relation(fields: [kpiId], references: [id], onDelete: Cascade)
  collector  User?         @relation("KPIDataCollector", fields: [collectedBy], references: [id], onDelete: SetNull)
  verifier   User?         @relation("KPIDataVerifier", fields: [verifiedBy], references: [id], onDelete: SetNull)

  @@index([kpiId, periodStart])
  @@index([collectedAt])
}

model ApiKey {
  id          String    @id @default(uuid()) @db.Uuid
  name        String
  keyHash     String    @unique
  userId      String    @db.Uuid
  scopes      String[]  @default([])
  expiresAt   DateTime
  lastUsedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  revokedAt   DateTime?

  user User @relation("UserApiKeys", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([keyHash])
  @@index([expiresAt])
}

model UnsubscribeToken {
  id          String    @id @default(uuid()) @db.Uuid
  token       String    @unique
  userId      String    @db.Uuid
  email       String
  notificationType String?
  createdAt   DateTime  @default(now())
  usedAt      DateTime?

  user User @relation("UserUnsubscribeTokens", fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
}

model EmailLog {
  id              String    @id @default(uuid()) @db.Uuid
  recipientEmail  String
  recipientUserId String?   @db.Uuid
  subject         String
  templateName    String
  notificationType String
  sentAt          DateTime  @default(now())
  deliveryStatus  String    @default("sent")
  errorMessage    String?
  messageId       String?

  recipient User? @relation("UserEmailLogs", fields: [recipientUserId], references: [id], onDelete: SetNull)

  @@index([recipientEmail])
  @@index([recipientUserId])
  @@index([sentAt])
  @@index([deliveryStatus])
}

// Project code sequence tracking
// Each year has its own sequence counter for PRJ-YYYY-NNNN format
model ProjectCode {
  id           String   @id @default(uuid()) @db.Uuid
  year         Int      @unique // e.g., 2025
  nextSequence Int      @default(1) // Next available sequence number
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([year])
}

model SystemSetting {
  id          String    @id @default(uuid()) @db.Uuid
  key         String    @unique @db.VarChar(255)
  value       Json
  dataType    String    @default("string") @db.VarChar(50)
  description String?
  isPublic    Boolean   @default(false)
  category    String?   @db.VarChar(100)
  updatedBy   String?   @db.Uuid
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  updater User? @relation("SystemSettingUpdater", fields: [updatedBy], references: [id], onDelete: SetNull)

  @@index([key])
  @@index([category])
  @@index([updatedBy])
}

model UserPreference {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  key       String   @db.VarChar(255)
  value     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, key])
  @@index([userId])
  @@index([key])
}

model Notification {
  id        String             @id @default(uuid()) @db.Uuid
  userId    String             @db.Uuid
  type      String
  title     String
  message   String
  status    NotificationStatus @default(UNREAD)
  data      Json?
  readAt    DateTime?
  archivedAt DateTime?
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  user User @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@index([createdAt])
}

model WebhookSubscription {
  id             String          @id @default(uuid()) @db.Uuid
  name           String
  url            String
  secret         String
  events         String[]
  channel        WebhookChannel  @default(GENERIC)
  isActive       Boolean         @default(true)
  failureCount   Int             @default(0)
  lastDeliveredAt DateTime?
  createdBy      String          @db.Uuid
  updatedBy      String?         @db.Uuid
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  creator User @relation("WebhookCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  updater User? @relation("WebhookUpdater", fields: [updatedBy], references: [id], onDelete: SetNull)

  @@index([isActive])
  @@index([createdBy])
  @@index([events], type: Gin)
}
